/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package pouet

import kotlinx.coroutines.DelicateCoroutinesApi
import kotlinx.coroutines.ExperimentalCoroutinesApi
import kotlinx.coroutines.asCoroutineDispatcher
import kotlinx.coroutines.async
import kotlinx.coroutines.newSingleThreadContext
import kotlinx.coroutines.runBlocking
import kotlinx.coroutines.withContext
import java.io.File
import java.util.concurrent.Executors
import kotlin.math.max
import kotlin.system.exitProcess
import kotlin.time.measureTime

class App {
    val greeting: String
        get() {
            return "Hello World!"
        }
}

@OptIn(ExperimentalCoroutinesApi::class, DelicateCoroutinesApi::class)
fun main() {
    val base = "/home/leo/projects/advent-of-code/2023/pouet"
    val inputTest = getInput("$base/inputTest.txt")
    val input = getInput("$base/input.txt")
    newSingleThreadContext("fuck").use { ctx ->
        runBlocking(ctx) {
            mainMeasuringTime({ solvePartOne(inputTest) }, "InputTest")
            mainMeasuringTime({ solvePartOne(input) }, "Input")
            mainMeasuringTime({ solve(inputTest) }, "InputTest")
            mainMeasuringTime({ solve(input) }, "Input")
            println("done")
            exitProcess(1)
        }
    }
}


suspend fun mainMeasuringTime(someFun: suspend () -> Number, toPrint: String) {
    val funTime = measureTime {
        val result = someFun()
        println("$toPrint $result")
    }
    println("$toPrint $funTime")

}

data class Input(val list: List<String>)

enum class Side { R, L, T, B }
data class Key(val x: Int, val y: Int, val side: Side)

data class Visited(val lasersHistory: Set<Key>)

fun getInput(fileName: String): Input {
    val file = File(fileName).readText()
    val lines = file.split("\n")

    return Input(lines)
}

fun solvePartOne(input: Input): Number {
    val maxX = input.list.first().length
    val maxY = input.list.size
    val lasers = setOf(Key(-1, 0, Side.R))
    val max = getThat(lasers, input, maxX, maxY)
    return max
}

suspend fun solve(input: Input): Number {
    val maxX = input.list.first().length
    val maxY = input.list.size

    println("Max X $maxX, Max Y $maxY")
    println()
    return withContext(Executors.newFixedThreadPool(100).asCoroutineDispatcher()) {
        val rangeX = 0..maxX
        val rangeY = 0..maxY
        return@withContext ((rangeY).map { y ->
            async {
                val lasers = setOf(Key(-1, y, Side.R))
                val lasers2 = setOf(Key(maxX + 1, y, Side.L))
                val a = getThat(lasers, input, maxX, maxY)
                val b = getThat(lasers2, input, maxX, maxY)
                println("$lasers $a")
                println("$lasers2 $b")
                max(a, b)
            }.let {
                it.start()
                it
            }
        } + (rangeX).map { x ->
            async {
                val lasers = setOf(Key(x, -1, Side.B))
                val lasers2 = setOf(Key(x, maxY + 1, Side.T))
                val a = getThat(lasers, input, maxX, maxY)
                val b = getThat(lasers2, input, maxX, maxY)
                println("$lasers $a")
                println("$lasers2 $b")
                max(a, b)
            }.let { it.start()
                it
            }
        }).map { it.await() }.max()

    }
}

fun getThat(lasers: Set<Key>, input: Input, maxX: Int, maxY: Int): Int {
    val visited = Visited(lasers)
    val visitedPoses = recurse(lasers, input, visited, maxX, maxY)
    val size = visitedPoses.lasersHistory.size(maxX, maxY)
    return size
}

tailrec fun recurse(lasers: Set<Key>, input: Input, visited: Visited, maxX: Int, maxY: Int): Visited {
    val (newLasers, newVisited) = travel(lasers, input.list, visited, maxX, maxY)
    //newVisited.lasersHistory.print(input.list.first().length, input.list.size)
    //val size = newVisited.lasersHistory.size(input.list.first().length, input.list.size)
    //println("Size: $size, Lasers count: ${newLasers.size}")
    return if (newVisited.lasersHistory.distinct() == visited.lasersHistory.distinct()) {
        newVisited
    } else recurse(
        newLasers,
        input,
        newVisited.copy(lasersHistory = newVisited.lasersHistory),
        maxX, maxY
    )
}

fun travel(lasers: Set<Key>, lines: List<String>, visited: Visited, maxX: Int, maxY: Int): Pair<Set<Key>, Visited> {
    return lasers.fold(listOf<Key>() to visited) { (lasersAcc, visitedAcc), laser ->
        val newPos = when (laser.side) {
            Side.T -> laser.x to laser.y - 1
            Side.B -> laser.x to laser.y + 1
            Side.R -> laser.x + 1 to laser.y
            Side.L -> laser.x - 1 to laser.y
        }

        val newSides = getNewSides(newPos, lines, laser.side)
        val newLasers = newSides.map { side ->
            Key(newPos.first, newPos.second, side)
        }
        val currentHistory = visitedAcc.lasersHistory + newLasers
        val newVisited = visitedAcc.copy(
            lasersHistory = currentHistory
        )
        (lasersAcc + newLasers).filter { it !in visited.lasersHistory && it.x in (-1..maxX + 1) && it.y in (-1..maxY + 1) } to newVisited
    }.let { (lasers, visited) ->
        lasers.toSet() to visited
    }
}


fun getNewSides(newPos: Pair<Int, Int>, lines: List<String>, side: Side): Set<Side> {
    val char = lines.getOrNull(newPos.second)?.getOrNull(newPos.first)
    val newSides = when (char) {
        '/' -> when (side) {
            Side.R -> setOf(Side.T)
            Side.L -> setOf(Side.B)
            Side.T -> setOf(Side.R)
            Side.B -> setOf(Side.L)
        }

        '\\' -> when (side) {
            Side.R -> setOf(Side.B)
            Side.L -> setOf(Side.T)
            Side.T -> setOf(Side.L)
            Side.B -> setOf(Side.R)
        }

        '-' -> when (side) {
            Side.R -> setOf(Side.R)
            Side.L -> setOf(Side.L)
            Side.T -> setOf(Side.L, Side.R)
            Side.B -> setOf(Side.L, Side.R)
        }

        '|' -> when (side) {
            Side.R -> setOf(Side.T, Side.B)
            Side.L -> setOf(Side.T, Side.B)
            Side.T -> setOf(Side.T)
            Side.B -> setOf(Side.B)
        }

        '.' -> setOf(side)
        null -> setOf()
        else -> throw Exception("Unknown char $char")
    }
    //println("X: ${newPos.first}, Y: ${newPos.second}, newSides: $newSides")
    return newSides
}

fun List<Key>.print(maxX: Int, maxY: Int) {
    println()
    (0..maxY).map { y ->
        (0..maxX).map { x ->
            if (this.find { key -> key.x == x && key.y == y } != null) {
                print("#")
            } else print(".")
        }
        println()
    }
}

fun Set<Key>.size(maxX: Int, maxY: Int): Int {
    return this.map { it.x to it.y }.distinct().filter { (x, y) ->
        x in 0..maxX-1 && y in 0..maxY-1
    }.size
}